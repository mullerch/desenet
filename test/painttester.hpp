#pragma once
#include <IJoystick>
#include <IJoystickObserver>
#include <IMonochromeDisplay>
#include <utils/MonochromeDisplayPainter>
#include <trace/Trace>


// Test image (Nokia logo).
static const uint8_t nokiaImage[] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x08,0x00,0x00,0x80,0x03,0x00,0xE0,0x11,
	0x00,0x00,0x00,0x00,0x00,0x08,0xF8,0x0F,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xFF,0xFF,0x7F,0x00,0x00,0x10,0x00,0x00,0x02,0x00,0xC0,0xFF,0xFF,0x0B,0x40,
	0x00,0x00,0x01,0x00,0xC0,0x00,0x80,0xFF,0x7F,0x80,0x00,0x00,0x00,0x00,0x08,0x9F,
	0x80,0xFC,0xFF,0x0F,0x00,0x00,0x00,0x40,0x00,0xFE,0x00,0xC0,0xDF,0x7F,0x00,0x00,
	0x00,0xA4,0x20,0xF9,0xF7,0x20,0xBF,0xF8,0x4F,0x49,0x12,0x09,0x00,0xEC,0xFF,0x0F,
	0xE8,0x86,0x7F,0x0D,0x00,0x02,0xE0,0xBC,0xFF,0xFF,0xF2,0x6E,0xFC,0xAF,0x24,0x89,
	0xA4,0xF1,0xFE,0xFF,0xC7,0xFF,0xEF,0x03,0x0F,0x00,0x00,0xC6,0xF7,0xFF,0x84,0xCF,
	0xEE,0x5F,0x04,0x11,0x21,0x12,0x9F,0xFF,0x1F,0xF8,0xEF,0xFF,0x00,0x08,0x84,0xC0,
	0xFE,0xFE,0xFF,0x17,0xFF,0xFF,0xAF,0x14,0x2A,0x55,0xFB,0xFB,0xFF,0xFF,0x02,0xF0,
	0x3D,0x04,0x08,0x01,0xD2,0xD7,0xFF,0xD7,0xDF,0x52,0xEA,0x95,0x52,0xA5,0x96,0xAC,
	0xFE,0xEF,0xFA,0x83,0x48,0x90,0x92,0x80,0x92,0x40,0xFF,0x7F,0x5D,0x9E,0x52,0xB1,
	0x52,0xAA,0x95,0x02,0xFA,0xFF,0x23,0x51,0xA5,0xAA,0x48,0x51,0x45,0x54,0x80,0xFF,
	0x5F,0xC9,0x2A,0x15,0x55,0xCA,0xAA,0xB2,0x02,0xDC,0x7F,0x2D,0x63,0x95,0x9A,0xAA,
	0x5A,0x56,0x09,0xA2,0xFE,0x4B,0xCC,0x92,0x96,0x4C,0x95,0x98,0x4A,0x01,0xFD,0x5F,
	0x6B,0x96,0x95,0x56,0xA6,0xD6,0x5C,0x81,0x84,0x7F,0x4A,0x99,0xA6,0x96,0x9A,0x95,
	0x32,0x03,0x80,0xFF,0x9F,0x6D,0x96,0x95,0x56,0x26,0xDB,0x6C,0x90,0xF7,0xFF,0x57,
	0xC0,0xAE,0x56,0x1B,0xAF,0xB4,0x4D,0xE7,0xFF,0x0F,0xF8,0x53,0xD6,0x5A,0x4D,0xB6,
	0xA5,0xEF,0xFD,0xFF,0xFE,0xFF,0x6D,0x6B,0x6D,0xBB,0xD5,0xDD,0xFD,0xFF,0xFF,0xFF,
	0x7F,0x6B,0x6B,0x6B,0xD5,0xB6,0xF9,0xFF,0xFF,0xFF,0xFF,0x6B,0xDB,0xD5,0xED,0xB6,
	0xBE,0xFF,0xFF,0xFF,0xFF,0x7F,0xDB,0xB6,0xAB,0xB5,0xFD,0xFF,0x5F,0x77,0xFD,0xEF,
	0xFB,0xBF,0xDF,0x77,0xEB,0x1B,0x50,0xC3,0x01,0x80,0xC3,0x06,0xC3,0x0B,0xFC,0xED,
	0x01,0x3E,0x0C,0x00,0x30,0x34,0x38,0x6C,0x80,0xF6,0x17,0xC0,0xC3,0x00,0x00,0xC3,
	0xC1,0xC3,0x07,0xF8,0xEB,0x01,0x28,0x0C,0xFF,0x30,0x0C,0x36,0x2C,0x0C,0xED,0x1F,
	0x02,0xC3,0xF0,0x0F,0x43,0xF0,0xC3,0xC3,0xF0,0xEF,0x61,0x20,0x0C,0xBF,0x30,0x80,
	0x3F,0x1C,0x1E,0xFE,0x1F,0x0E,0xC0,0x70,0x0F,0x43,0x70,0xC3,0x01,0xE0,0x7D,0xE1,
	0x01,0x0C,0xFF,0x30,0x0C,0x3E,0x0C,0x00,0xFC,0x1F,0x3E,0xC0,0x00,0x00,0xC3,0xC1,
	0xC3,0x00,0xC0,0xFF,0xE1,0x07,0x0C,0x00,0x30,0x3C,0x38,0x84,0x7F,0xF8,0x1F,0xFE,
	0xC0,0x01,0x80,0xC3,0x07,0x43,0xF8,0x87,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
};


/**
 * @ingroup test
 * This class can be used to test the display driver. It uses the display for output and the joystick
 * to trigger the drawings.
 */
class PaintTester : public IJoystickObserver
{
public:

	/**
	 * Constructor, creates a new test object to test the driver that implements the IMonochromeDisplay
	 * interface. It uses the joystick to proceed from one drawing test to the next and of course a display
	 * to paint into. Note that this test uses the MonochromeDisplayPainter class for accelerated access.
	 */
	PaintTester( IJoystick & joystick , IMonochromeDisplay & display )
		: _joystick( joystick ) , _display( display )
	{
		// Initialize the joystick and set the observer to myself.
		_joystick.setObserver( this );
	}

	/**
	 * IJoystickObserver implementation: We react directly on the joystick event.
	 */
	void onPositionChange( IJoystick::Position position )
	{
		static int testNumber = 1;

		// Ignore release event.
		if ( position == IJoystick::Center ) return;

		//Â Depending on the joystick move, navigate inside test procedures.
		switch( position )
		{
			case IJoystick::Up:
			case IJoystick::Left:
				testNumber = std::min( 24 , testNumber + 1 );
				break;

			case IJoystick::Down:
			case IJoystick::Right:
				testNumber = std::max( 2 , testNumber - 1 );
				break;

			default:
				break;
		}

		MonochromeDisplayPainter p( &_display , false );

		// Each second test will be just the previous one inverted.
		p.clear( testNumber % 2 ? IMonochromeDisplay::Black : IMonochromeDisplay::White );
		IMonochromeDisplay::PixelColor color = testNumber % 2 ? IMonochromeDisplay::White : IMonochromeDisplay::Black;

		switch( testNumber / 2 )
		{
			case 1:
				Trace::out( "drawPixel() - You should see 5 pixels on the display..." );
				p.drawPixel( IMonochromeDisplay::Point ( 0 , 0 ) , color );
				p.drawPixel( IMonochromeDisplay::Point ( 83 , 47 ) , color );
				p.drawPixel( IMonochromeDisplay::Point ( 83 , 0 ) , color );
				p.drawPixel( IMonochromeDisplay::Point ( 0 , 47 ) , color );
				p.drawPixel( IMonochromeDisplay::Point ( 42 , 24 ) , color );
				break;

			case 2:
				Trace::out( "drawPixel() - You should see a pixel grid." );
				for ( int x = 0 ; x < 84 ; x += 2 )
					for ( int y = 0 ; y < 48 ; y += 2 )
						p.drawPixel( IMonochromeDisplay::Point( x , y ) , color );
				break;

			case 3:
				Trace::out( "drawLine() - You should see a big X across the whole screen." );
				p.drawLine( IMonochromeDisplay::Point( 0 , 0 ) , IMonochromeDisplay::Point( 83 , 47 ) , color );
				p.drawLine( IMonochromeDisplay::Point( 83 , 0 ) , IMonochromeDisplay::Point( 0 , 47 ) , color );
				break;

			case 4:
				Trace::out( "drawLine() - You should see a line grid." );
				for ( int x = 0 ; x < 84 ; x += 2 )
					p.drawLine( IMonochromeDisplay::Point( x , 0 ) , IMonochromeDisplay::Point( x , 47 ) , color );

				for ( int y = 0 ; y < 48 ; y += 2 )
					p.drawLine( IMonochromeDisplay::Point( 0 , y ) , IMonochromeDisplay::Point( 83, y ) , color );
				break;

			case 5:
				Trace::out( "drawLine() - You should see plenty diagonal lines on the screen." );
				for ( int x = 0 ; x < 84 ; x += 8 )
					p.drawLine( IMonochromeDisplay::Point( x , 0 ) ,
							    IMonochromeDisplay::Point( 83 , 47 - x * 48 / 84  ) , color );
				for ( int y = 0 ; y < 48 ; y += 5 )
					p.drawLine( IMonochromeDisplay::Point( 0 , y ) ,
								IMonochromeDisplay::Point( 83 - y * 84 / 48 , 47  ) , color );
				break;

			case 6:
				Trace::out( "drawRectangle() - You should see two rectangles on the screen, one filled and one not." );
				p.drawRectangle( IMonochromeDisplay::Point( 0 , 0 ) , _display.resolution() , color );
				p.drawRectangle( IMonochromeDisplay::Point( 10 , 10 ) , IMonochromeDisplay::Size( 64 , 28 ) , color , color );
				break;

			case 7:
				Trace::out( "drawRectangle() - You should see 5 rectangles with different border colors and fills." );
				p.drawRectangle( IMonochromeDisplay::Point( 20 , 1 ) , IMonochromeDisplay::Size( 44 , 46 ) , color );
				p.drawRectangle( IMonochromeDisplay::Point( 1 , 10 ) , IMonochromeDisplay::Size( 38 , 10 ) , color );
				p.drawRectangle( IMonochromeDisplay::Point( 45 , 10 ) , IMonochromeDisplay::Size( 38 , 10 ) , color , color );
				p.drawRectangle( IMonochromeDisplay::Point( 1 , 30 ) , IMonochromeDisplay::Size( 38 , 10 ) , color , IMonochromeDisplay::White );
				p.drawRectangle( IMonochromeDisplay::Point( 45 , 30 ) , IMonochromeDisplay::Size( 38 , 10 ) , color , IMonochromeDisplay::Black );
				break;

			case 8:
				Trace::out( "drawEllipse() - You should see two ellipses on the screen, one filled and one not." );
				p.drawEllipse( IMonochromeDisplay::Point( 0 , 0 ) , _display.resolution() , color );
				p.drawEllipse( IMonochromeDisplay::Point( 10 , 10 ) , IMonochromeDisplay::Size( 64 , 28 ) , color , color );
				break;

			case 9:
				Trace::out( "drawEllipse() - You should see 5 ellipses with different border colors and fills." );
				p.drawEllipse( IMonochromeDisplay::Point( 20 , 1 ) , IMonochromeDisplay::Size( 44 , 46 ) , color );
				p.drawEllipse( IMonochromeDisplay::Point( 1 , 10 ) , IMonochromeDisplay::Size( 38 , 10 ) , color );
				p.drawEllipse( IMonochromeDisplay::Point( 45 , 10 ) , IMonochromeDisplay::Size( 38 , 10 ) , color , color );
				p.drawEllipse( IMonochromeDisplay::Point( 1 , 30 ) , IMonochromeDisplay::Size( 38 , 10 ) , color , IMonochromeDisplay::White );
				p.drawEllipse( IMonochromeDisplay::Point( 45 , 30 ) , IMonochromeDisplay::Size( 38 , 10 ) , color , IMonochromeDisplay::Black );
				break;

			case 10:
				Trace::out( "drawText() - a top left, b top right, c bottom left, d bottom right." );
				p.drawText( IMonochromeDisplay::Point( 0 , 0 ) , "a" , color );
				p.drawText( IMonochromeDisplay::Point( 84 - 5 , 0 ) , "b" , color );
				p.drawText( IMonochromeDisplay::Point( 0 , 48 - 7 ) , "c" , color );
				p.drawText( IMonochromeDisplay::Point( 84 - 5 , 48 - 7 ) , "d" , color );
				break;

			case 11:
				Trace::out( "drawText() - Display should be completely filled with characters." );
				p.drawText( IMonochromeDisplay::Point( 0 , 0 ) , "TEST-TEST-TEST" , color );
				p.drawText( IMonochromeDisplay::Point( 0 , 8 ) , "abcdefghijklmn" , color );
				p.drawText( IMonochromeDisplay::Point( 0 , 16 ) , "tset-tset-tset" , color );
				p.drawText( IMonochromeDisplay::Point( 0 , 24 ) , "TSET-TSET-TSET" , color );
				p.drawText( IMonochromeDisplay::Point( 0 , 32 ) , "SEPP-SEPP-SEPP" , color );
				p.drawText( IMonochromeDisplay::Point( 0 , 40 ) , "ABCDEFGHIJKLMN" , color );
				break;

			case 12:
				Trace::out( "drawBitmap() - You should see the Nokia logo." );
				p.drawBitmap( IMonochromeDisplay::Point( 0 , 0 ) , IMonochromeDisplay::Size( 84 , 48 ) , nokiaImage );
				break;
		}
	}

private:
	IJoystick & _joystick;
	IMonochromeDisplay & _display;
};
